// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Erode
#pragma kernel Dilation
#pragma kernel Tex2Buffer
#pragma kernel Buffer2Tex
#pragma kernel Thin

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Tex;
Texture2D<float4> Image;

RWStructuredBuffer<float4> TexBuffer;

inline int F(int2 xy)
{
	return int(xy.x * 256 + xy.y);
}

[numthreads(32, 32, 1)]
void Erode(uint3 id : SV_DispatchThreadID)
{
	int2 xy = id.xy;
	//float4 sum = Image[xy + float2(-1, -1)] + Image[xy + float2(-1, 0)] + Image[xy + float2(-1, 1)]
	//		   + Image[xy + float2(0, -1)] + Image[xy + float2(0, 0)] + Image[xy + float2(0, 1)]
	//		   + Image[xy + float2(1, -1)] + Image[xy + float2(1, 0)] + Image[xy + float2(1, 1)];
	//float bin = step(9, sum.x);
	//Tex[id.xy] = float4(bin, bin, bin, 1);
	float4 sum = TexBuffer[F(xy + int2(-1, -1))] + TexBuffer[F(xy + int2(-1, 0))] + TexBuffer[F(xy + int2(-1, 1))]
			   + TexBuffer[F(xy + int2(0, -1))] + TexBuffer[F(xy + int2(0, 0))] + TexBuffer[F(xy + int2(0, 1))]
			   + TexBuffer[F(xy + int2(1, -1))] + TexBuffer[F(xy + int2(1, 0))] + TexBuffer[F(xy + int2(1, 1))];
	float bin = step(9, sum.x);
	TexBuffer[F(xy)] = float4(bin, bin, bin, 1);
}

[numthreads(32, 32, 1)]
void Dilation(uint3 id : SV_DispatchThreadID)
{
	int2 xy = id.xy;
	//float4 sum = Image[xy + float2(-1, -1)] + Image[xy + float2(-1, 0)] + Image[xy + float2(-1, 1)]
	//		   + Image[xy + float2(0, -1)] + Image[xy + float2(0, 0)] + Image[xy + float2(0, 1)]
	//		   + Image[xy + float2(1, -1)] + Image[xy + float2(1, 0)] + Image[xy + float2(1, 1)];
	//float bin = step(1, sum.x);
	//Tex[id.xy] = float4(bin, bin, bin, 1);
	float4 sum = TexBuffer[F(xy + int2(-1, -1))] + TexBuffer[F(xy + int2(-1, 0))] + TexBuffer[F(xy + int2(-1, 1))]
			   + TexBuffer[F(xy + int2(0, -1))] + TexBuffer[F(xy + int2(0, 0))] + TexBuffer[F(xy + int2(0, 1))]
			   + TexBuffer[F(xy + int2(1, -1))] + TexBuffer[F(xy + int2(1, 0))] + TexBuffer[F(xy + int2(1, 1))];
	float bin = step(1, sum.x);
	TexBuffer[F(xy)] = float4(bin, bin, bin, 1);
}

float Edge(float2 xys[9])
{
	float gx[9] = {-1, 0, 1,
                   -2, 0, 2,
                   -1, 0, 1};
	float gy[9] = {-1, -2, -1,
				    0,  0,  0,
				    1,  2,  1};

	float edgeX = 0;
	float edgeY = 0;

	for (int i = 0; i < 9; i++)
	{
		float l = TexBuffer[F(xys[i].xy)].x;
		edgeX += l * gx[i];
		edgeY += l * gy[i];
	}
	return abs(edgeX) + abs(edgeY);
}

[numthreads(32, 32, 1)]
void Thin(uint3 id : SV_DispatchThreadID, uint index : SV_GroupIndex)
{
	float2 uv[9];
	uv[0] = id.xy + float2(-1, 1);
	uv[1] = id.xy + float2(0, 1);
	uv[2] = id.xy + float2(1, 1);
	uv[3] = id.xy + float2(-1, 0);
	uv[4] = id.xy + float2(0, 0);
	uv[5] = id.xy + float2(1, 0);
	uv[6] = id.xy + float2(-1, -1);
	uv[7] = id.xy + float2(0, -1);
	uv[8] = id.xy + float2(1, -1);
	float e = Edge(uv);
	TexBuffer[F(id.xy)] = float4(e, e, e, 1);
}

[numthreads(32, 32, 1)]
void Tex2Buffer(uint3 id : SV_DispatchThreadID)
{
	TexBuffer[F(id.xy)] = Image[id.xy];
}

[numthreads(32, 32, 1)]
void Buffer2Tex(uint3 id : SV_DispatchThreadID)
{
	Tex[id.xy] = TexBuffer[F(id.xy)];
}
